/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/box-and-pointer.js":
/*!*********************************!*\
  !*** ./dist/box-and-pointer.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _types_BoxObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types/BoxObject */ \"./dist/types/BoxObject.js\");\n/* harmony import */ var html_parsed_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! html-parsed-element */ \"./node_modules/html-parsed-element/esm/index.js\");\n/* harmony import */ var _types_ElementInfo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types/ElementInfo */ \"./dist/types/ElementInfo.js\");\n/* harmony import */ var _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types/ContentObject */ \"./dist/types/ContentObject.js\");\n/* harmony import */ var sparse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! sparse */ \"./node_modules/sparse/dist/index.js\");\n/* harmony import */ var sparse__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(sparse__WEBPACK_IMPORTED_MODULE_4__);\n\r\n\r\n\r\n\r\n\r\nclass BoxAndPointerElement extends html_parsed_element__WEBPACK_IMPORTED_MODULE_1__.default {\r\n    constructor() {\r\n        super();\r\n        this.arrowBindings = [];\r\n        this.slashes = [];\r\n        this.rows = [];\r\n        this.objectToPreparedEltBindings = new Map();\r\n        this.objectToEltBindings = new Map();\r\n        this.shadow = this.attachShadow({ mode: \"open\" });\r\n        this.shadow.innerHTML = \"\";\r\n    }\r\n    async parsedCallback() {\r\n        const graph = this.calculateGraphFromDOM();\r\n        for (const object of graph) {\r\n            this.prepareRenderRoot(object);\r\n        }\r\n        for (const object of graph) {\r\n            this.renderFromBoxObject(object, this.pushRow([]), true);\r\n        }\r\n        for (let row of this.rows) {\r\n            this.shadow.appendChild(row);\r\n        }\r\n        const plumb = jsPlumb.getInstance({\r\n            Container: this.shadow,\r\n            PaintStyle: { stroke: \"black\", strokeWidth: 1.5, fill: \"none\" }\r\n        });\r\n        // Make sure stylesheets are loaded. This ensures cross-browser compatibility.\r\n        const stylesheets = [document.getElementById('box-and-pointer-style').cloneNode()];\r\n        if (this.hasAttribute('stylesheet')) {\r\n            const stylesheet = document.createElement('link');\r\n            stylesheet.rel = 'stylesheet';\r\n            stylesheet.href = this.getAttribute('stylesheet');\r\n            stylesheets.push(stylesheet);\r\n        }\r\n        let toLoad = stylesheets.length;\r\n        for (let ss of stylesheets) {\r\n            ss.addEventListener('load', () => --toLoad === 0 && plumb.ready(loadArrows));\r\n        }\r\n        this.shadow.prepend(...stylesheets);\r\n        const loadArrows = () => {\r\n            const overlays = [[\"Arrow\", { location: 1, width: 8, length: 12, }], [\"Label\", { location: 0, cssClass: \"bp--pointer-source\" }]];\r\n            for (const binding of this.arrowBindings) {\r\n                if (binding.side !== \"unknown\") {\r\n                    if (binding.side === \"Top\") {\r\n                        binding.to.style.width = \"2em\";\r\n                    }\r\n                    plumb.connect({\r\n                        source: binding.from,\r\n                        target: binding.to,\r\n                        anchors: [\"Center\", binding.side],\r\n                        overlays: overlays,\r\n                        connector: \"Straight\",\r\n                        endpoint: \"Blank\"\r\n                    });\r\n                    if (binding.side === \"Top\") {\r\n                        binding.to.style.width = \"\";\r\n                    }\r\n                }\r\n                else {\r\n                    plumb.connect({\r\n                        source: binding.from,\r\n                        target: binding.to,\r\n                        anchors: [\"Center\", [\"Continuous\", { faces: ['top', 'left', 'bottom'] }]],\r\n                        overlays: overlays,\r\n                        connector: [binding.from.parentElement.parentElement === binding.to.parentElement.parentElement ? \"StateMachine\" : \"Bezier\", { curviness: 40, proximityLimit: 0, margin: 0.01 }],\r\n                        endpoint: \"Blank\"\r\n                    });\r\n                }\r\n            }\r\n            for (const slashTarget of this.slashes) {\r\n                plumb.connect({\r\n                    source: slashTarget,\r\n                    target: slashTarget,\r\n                    anchors: [\"TopRight\", \"BottomLeft\"],\r\n                    connector: \"Straight\",\r\n                    endpoint: \"Blank\"\r\n                });\r\n            }\r\n            // fix pointer positions\r\n            const rect = this.getBoundingClientRect();\r\n            for (const arrow of this.shadow.querySelectorAll('.jtk-overlay, .jtk-endpoint, .jtk-connector')) {\r\n                arrow.style.top = `${+arrow.style.top.slice(0, -2) - rect.top - window.scrollY}px`;\r\n                arrow.style.left = `${+arrow.style.left.slice(0, -2) - rect.left - window.scrollX}px`;\r\n            }\r\n            this.classList.add('bp--loaded');\r\n            // window.addEventListener('resize', e => plumb.repaintEverything(true));\r\n        };\r\n    }\r\n    getChildren(elt, allowText = false) {\r\n        return [...elt.childNodes].flatMap((node) => {\r\n            if (node instanceof HTMLElement) {\r\n                if (_types_ElementInfo__WEBPACK_IMPORTED_MODULE_2__.internalElementTagNames.has(node.tagName)) {\r\n                    return [node];\r\n                }\r\n                else {\r\n                    // Invalid element\r\n                    console.error('Found unexpected element %o in %o. Did you misspell a tag name?', node, elt);\r\n                    return [];\r\n                }\r\n            }\r\n            else {\r\n                // Invalid node\r\n                switch (node.nodeType) {\r\n                    case Node.TEXT_NODE:\r\n                        const text = node.nodeValue?.trim();\r\n                        if (text) {\r\n                            if (allowText) {\r\n                                return [...text.matchAll(/\\S+/g)].map(x => x[0]);\r\n                            }\r\n                            console.error('Found text %o in %o. Did you mean to use <lisp></lisp>?', node, elt);\r\n                        }\r\n                        break;\r\n                    case Node.COMMENT_NODE:\r\n                        break;\r\n                    default:\r\n                        console.error('Found unexpected node %o in %o.', node, elt);\r\n                        break;\r\n                }\r\n                return [];\r\n            }\r\n        });\r\n    }\r\n    search(node, callback) {\r\n        const visited = new Set();\r\n        const _search = (node) => {\r\n            if (visited.has(node)) {\r\n                return;\r\n            }\r\n            visited.add(node);\r\n            callback(node);\r\n            switch (node.kind) {\r\n                case _types_BoxObject__WEBPACK_IMPORTED_MODULE_0__.UIObjectType.Single:\r\n                    if (node.contents.kind === _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.ContentObjectType.Pointer) {\r\n                        _search(node.contents.target);\r\n                    }\r\n                    break;\r\n                case _types_BoxObject__WEBPACK_IMPORTED_MODULE_0__.UIObjectType.Pair:\r\n                    if (node.lhs.kind === _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.ContentObjectType.Pointer) {\r\n                        _search(node.lhs.target);\r\n                    }\r\n                    if (node.rhs.kind === _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.ContentObjectType.Pointer) {\r\n                        _search(node.rhs.target);\r\n                    }\r\n                    break;\r\n            }\r\n        };\r\n        _search(node);\r\n    }\r\n    calculateGraphFromDOM() {\r\n        const namedObjects = {};\r\n        const refResolutionCallbacks = [];\r\n        const graphRoots = [];\r\n        const graphRootNames = new Set();\r\n        const noRootSymbol = Symbol();\r\n        /**\r\n         * Map from a named element to the names of every root whose tree is pointing to it.\r\n         * If a tree pointing to it has no name, it will use noRootSymbol instead.\r\n         */\r\n        const graphRootRefGraph = {};\r\n        const rootElements = this.getChildren(this);\r\n        const forcedRoots = new Set();\r\n        let $name = noRootSymbol;\r\n        const generateBoxObject = (element) => {\r\n            let object;\r\n            switch (element.tagName) {\r\n                case _types_ElementInfo__WEBPACK_IMPORTED_MODULE_2__.Tags.Box:\r\n                    let [elt, ...extraElts] = this.getChildren(element, true);\r\n                    for (const extraElt of extraElts) {\r\n                        if (typeof extraElt === 'string') {\r\n                            console.error(\"Found extraneous text node %o in %o could be interpreted as a value.\", extraElt, element);\r\n                        }\r\n                        else {\r\n                            console.error(\"Found extraneous element %o in %o.\", extraElt, element);\r\n                        }\r\n                    }\r\n                    if (!elt) {\r\n                        console.error(\"<box> element %o contains no values, expected one.\", element);\r\n                        object = (0,_types_BoxObject__WEBPACK_IMPORTED_MODULE_0__.makeSingle)({ contents: _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.emptySingleton });\r\n                    }\r\n                    else {\r\n                        object = (0,_types_BoxObject__WEBPACK_IMPORTED_MODULE_0__.makeSingle)({ contents: typeof elt === 'string' ? (0,_types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.makeString)({ value: elt }) : generateContentObject(elt) });\r\n                    }\r\n                    break;\r\n                case _types_ElementInfo__WEBPACK_IMPORTED_MODULE_2__.Tags.Pair: {\r\n                    const [lhsElt, rhsElt, ...extraElts] = this.getChildren(element, true);\r\n                    for (const extraElt of extraElts) {\r\n                        if (typeof extraElt === 'string') {\r\n                            console.error(\"Found extraneous text node %o in %o could be interpreted as a value.\", extraElt, element);\r\n                        }\r\n                        else {\r\n                            console.error(\"Found extraneous element %o in %o.\", extraElt, element);\r\n                        }\r\n                    }\r\n                    if (!rhsElt) {\r\n                        console.error(\"<pair> element %o only contains one value, expected two.\", element);\r\n                        object = (0,_types_BoxObject__WEBPACK_IMPORTED_MODULE_0__.makePair)({\r\n                            lhs: typeof lhsElt === 'string' ? (0,_types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.makeString)({ value: lhsElt }) : generateContentObject(lhsElt),\r\n                            rhs: _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.emptySingleton\r\n                        });\r\n                    }\r\n                    else if (!lhsElt) {\r\n                        console.error(\"<pair> element %o contains no values, expected two.\", element);\r\n                        object = (0,_types_BoxObject__WEBPACK_IMPORTED_MODULE_0__.makePair)({\r\n                            lhs: _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.emptySingleton,\r\n                            rhs: _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.emptySingleton\r\n                        });\r\n                    }\r\n                    else {\r\n                        object = (0,_types_BoxObject__WEBPACK_IMPORTED_MODULE_0__.makePair)({\r\n                            lhs: typeof lhsElt === 'string' ? (0,_types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.makeString)({ value: lhsElt }) : generateContentObject(lhsElt),\r\n                            rhs: typeof rhsElt === 'string' ? (0,_types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.makeString)({ value: rhsElt }) : generateContentObject(rhsElt)\r\n                        });\r\n                    }\r\n                    break;\r\n                }\r\n                case _types_ElementInfo__WEBPACK_IMPORTED_MODULE_2__.Tags.List: {\r\n                    const elts = this.getChildren(element, true);\r\n                    if (elts.length === 0) {\r\n                        object = (0,_types_BoxObject__WEBPACK_IMPORTED_MODULE_0__.makeSingle)({ contents: _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.emptySingleton });\r\n                    }\r\n                    else if (element.hasAttribute(_types_ElementInfo__WEBPACK_IMPORTED_MODULE_2__.Attributes.ExplicitTail)) {\r\n                        const tailElt = elts[elts.length - 1];\r\n                        const tail = typeof tailElt === 'string' ? (0,_types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.makeString)({ value: tailElt }) : generateContentObject(tailElt);\r\n                        object = elts.slice(0, -1).reduceRight((prev, lhsElt) => (0,_types_BoxObject__WEBPACK_IMPORTED_MODULE_0__.makePair)({\r\n                            lhs: typeof lhsElt === 'string' ? (0,_types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.makeString)({ value: lhsElt }) : generateContentObject(lhsElt),\r\n                            rhs: prev === null ? tail : (0,_types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.makePointer)({ target: prev })\r\n                        }), null);\r\n                    }\r\n                    else {\r\n                        object = elts.reduceRight((prev, lhsElt) => (0,_types_BoxObject__WEBPACK_IMPORTED_MODULE_0__.makePair)({\r\n                            lhs: typeof lhsElt === 'string' ? (0,_types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.makeString)({ value: lhsElt }) : generateContentObject(lhsElt),\r\n                            rhs: prev === null ? _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.emptySingleton : (0,_types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.makePointer)({ target: prev })\r\n                        }), null);\r\n                    }\r\n                    break;\r\n                }\r\n                case _types_ElementInfo__WEBPACK_IMPORTED_MODULE_2__.Tags.Lisp: {\r\n                    element.childNodes.forEach(node => {\r\n                        if (![Node.TEXT_NODE, Node.COMMENT_NODE].includes(node.nodeType)) {\r\n                            console.error(\"<lisp> elements can only contain text, but found %o in %o.\", node, element);\r\n                        }\r\n                    });\r\n                    const convertMaybeSExpressionToContentObject = (val) => {\r\n                        if (val instanceof sparse__WEBPACK_IMPORTED_MODULE_4__.SExpression) {\r\n                            return (0,_types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.makePointer)({ target: convertSExpressionToBoxObject(val) });\r\n                        }\r\n                        if (val == null) {\r\n                            return _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.emptySingleton;\r\n                        }\r\n                        return (0,_types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.makeString)({ value: val });\r\n                    };\r\n                    const convertSExpressionToBoxObject = (expr) => {\r\n                        return (0,_types_BoxObject__WEBPACK_IMPORTED_MODULE_0__.makePair)({ lhs: convertMaybeSExpressionToContentObject(expr.head), rhs: convertMaybeSExpressionToContentObject(expr.tail) });\r\n                    };\r\n                    const parsed = (0,sparse__WEBPACK_IMPORTED_MODULE_4__.parse)(element.innerText).head;\r\n                    if (!(parsed instanceof sparse__WEBPACK_IMPORTED_MODULE_4__.SExpression)) {\r\n                        console.error(\"%o is not valid content for a <lisp> element. Did you mean to surround it with parentheses?\", element.innerText);\r\n                        object = (0,_types_BoxObject__WEBPACK_IMPORTED_MODULE_0__.makeSingle)({ contents: _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.emptySingleton });\r\n                    }\r\n                    else {\r\n                        object = convertSExpressionToBoxObject(parsed);\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    console.error(\"Found <%s> element, but only <box>, <pair>, <list>, and <lisp> elements are permitted here.\", element.tagName.toLowerCase());\r\n                    object = (0,_types_BoxObject__WEBPACK_IMPORTED_MODULE_0__.makeSingle)({ contents: generateContentObject(element) });\r\n                    break;\r\n            }\r\n            const name = element.getAttribute(_types_ElementInfo__WEBPACK_IMPORTED_MODULE_2__.Attributes.Name);\r\n            if (name) {\r\n                namedObjects[name] = object;\r\n            }\r\n            if (element.getAttribute(_types_ElementInfo__WEBPACK_IMPORTED_MODULE_2__.Attributes.ForceRoot) !== null) {\r\n                forcedRoots.add(object);\r\n            }\r\n            return object;\r\n        };\r\n        const generateContentObject = (element) => {\r\n            switch (element.tagName) {\r\n                case _types_ElementInfo__WEBPACK_IMPORTED_MODULE_2__.Tags.Pointer: {\r\n                    if (element.childNodes.length > 0) {\r\n                        console.error(\"<pointer> element %o cannot have any children.\", element);\r\n                    }\r\n                    const ref = element.getAttribute(_types_ElementInfo__WEBPACK_IMPORTED_MODULE_2__.Attributes.Ref);\r\n                    if (!ref) {\r\n                        console.error(\"<pointer> element %o must have a ref attribute, but is missing one.\", element);\r\n                        return _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.emptySingleton;\r\n                    }\r\n                    (graphRootRefGraph[ref] ?? (graphRootRefGraph[ref] = new Set())).add($name);\r\n                    if (ref in namedObjects) {\r\n                        return (0,_types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.makePointer)({ target: namedObjects[ref] });\r\n                    }\r\n                    // ref doesn't exist yet\r\n                    const pointer = (0,_types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.makeNullPointer)();\r\n                    refResolutionCallbacks.push(() => {\r\n                        if (ref in namedObjects) {\r\n                            (0,_types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.transformContentObject)(pointer, (0,_types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.makePointer)({ target: namedObjects[ref] }));\r\n                        }\r\n                        else {\r\n                            console.error(\"<pointer> element %o has ref=%o, but no element with that name exists.\", element, ref);\r\n                            (0,_types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.transformContentObject)(pointer, _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.emptySingleton);\r\n                        }\r\n                    });\r\n                    return pointer;\r\n                }\r\n                case _types_ElementInfo__WEBPACK_IMPORTED_MODULE_2__.Tags.Value:\r\n                    return (0,_types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.makeRich)({ children: element.childNodes });\r\n                case _types_ElementInfo__WEBPACK_IMPORTED_MODULE_2__.Tags.Empty:\r\n                    return _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.emptySingleton;\r\n            }\r\n            return (0,_types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.makePointer)({ target: generateBoxObject(element) });\r\n        };\r\n        for (const element of rootElements) {\r\n            const name = element.getAttribute(_types_ElementInfo__WEBPACK_IMPORTED_MODULE_2__.Attributes.Name);\r\n            $name = name ?? noRootSymbol;\r\n            const object = generateBoxObject(element);\r\n            if (!name || forcedRoots.has(object)) {\r\n                // If it's unnamed then it can't be referenced so it must be a graph root.\r\n                graphRoots.push(object);\r\n            }\r\n            else {\r\n                graphRootNames.add(name);\r\n            }\r\n        }\r\n        for (const root of forcedRoots) {\r\n            if (!graphRoots.includes(root)) {\r\n                graphRoots.push(root);\r\n            }\r\n        }\r\n        // Resolve previously missing bindings\r\n        for (const callback of refResolutionCallbacks) {\r\n            callback();\r\n        }\r\n        while (true) {\r\n            // Find which graph roots aren't covered by our existing vertex set\r\n            const missing = new Set([...graphRootNames].map(x => namedObjects[x]));\r\n            for (const root of graphRoots) {\r\n                this.search(root, node => missing.delete(node));\r\n            }\r\n            if (missing.size === 0) {\r\n                break;\r\n            }\r\n            const availableFrom = new Map();\r\n            for (const root of missing) {\r\n                availableFrom.set(root, 0);\r\n            }\r\n            for (const root of missing) {\r\n                this.search(root, node => {\r\n                    if (availableFrom.has(node)) {\r\n                        availableFrom.set(node, availableFrom.get(node) + 1);\r\n                    }\r\n                });\r\n            }\r\n            const pathsToHistogram = [];\r\n            for (const [root, sources] of availableFrom.entries()) {\r\n                (pathsToHistogram[sources] ?? (pathsToHistogram[sources] = [])).push(root);\r\n            }\r\n            for (let i = 0; i < pathsToHistogram.length; i++) {\r\n                const roots = pathsToHistogram[i];\r\n                if (roots && roots.length > 0) {\r\n                    if (i === 0) {\r\n                        // All roots with 0 paths to them are true roots.\r\n                        for (const root of roots) {\r\n                            graphRoots.push(root);\r\n                        }\r\n                    }\r\n                    else {\r\n                        // We have a cycle, so just pick an arbitrary root to use.\r\n                        graphRoots.push(roots[0]);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            ;\r\n        }\r\n        return graphRoots;\r\n    }\r\n    pushRow(referencePadding) {\r\n        const rowElt = document.createElement('div');\r\n        rowElt.classList.add(\"bp--row\");\r\n        for (const elt of referencePadding) {\r\n            const clone = elt.cloneNode(true);\r\n            clone.classList.add(\"bp--hidden\");\r\n            rowElt.appendChild(clone);\r\n        }\r\n        this.rows.push(rowElt);\r\n        return rowElt;\r\n    }\r\n    prepareRenderRoot(object) {\r\n        this.objectToPreparedEltBindings.set(object, document.createElement('div'));\r\n    }\r\n    renderFromBoxObject(object, row, root = false) {\r\n        let preparedElt = this.objectToPreparedEltBindings.get(object);\r\n        if (!root && preparedElt) {\r\n            return preparedElt;\r\n        }\r\n        const position = row.childElementCount;\r\n        const container = document.createElement('div');\r\n        container.classList.add('bp--box-container');\r\n        row.appendChild(container);\r\n        this.objectToEltBindings.set(object, container);\r\n        let headBox;\r\n        let tailBox;\r\n        switch (object.kind) {\r\n            case _types_BoxObject__WEBPACK_IMPORTED_MODULE_0__.UIObjectType.Single:\r\n                tailBox = object.contents;\r\n                break;\r\n            case _types_BoxObject__WEBPACK_IMPORTED_MODULE_0__.UIObjectType.Pair:\r\n                headBox = object.lhs;\r\n                tailBox = object.rhs;\r\n                break;\r\n        }\r\n        let headBoxElt;\r\n        let headBoxTargetUnknown = false;\r\n        if (headBox) {\r\n            headBoxElt = preparedElt ?? document.createElement('div');\r\n            headBoxElt.classList.add('bp--box');\r\n            container.prepend(headBoxElt);\r\n            switch (headBox.kind) {\r\n                case _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.ContentObjectType.Empty:\r\n                    this.slashes.push(headBoxElt);\r\n                    break;\r\n                case _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.ContentObjectType.String:\r\n                    const valueContainer = document.createElement('span');\r\n                    valueContainer.classList.add(\"bp--value-container\");\r\n                    valueContainer.innerText = headBox.value;\r\n                    headBoxElt.appendChild(valueContainer);\r\n                    break;\r\n                case _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.ContentObjectType.Rich:\r\n                    for (const elt of headBox.children) {\r\n                        headBoxElt.appendChild(elt);\r\n                    }\r\n                    break;\r\n                case _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.ContentObjectType.Pointer:\r\n                    const target = this.objectToEltBindings.get(headBox.target);\r\n                    if (target) {\r\n                        this.arrowBindings.push({ from: headBoxElt, to: target, side: \"unknown\" });\r\n                    }\r\n                    else {\r\n                        headBoxTargetUnknown = true;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        // tailBox\r\n        let tailBoxElt = headBox ? document.createElement('div') : preparedElt ?? document.createElement('div');\r\n        tailBoxElt.classList.add('bp--box');\r\n        container.appendChild(tailBoxElt);\r\n        switch (tailBox.kind) {\r\n            case _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.ContentObjectType.Empty:\r\n                this.slashes.push(tailBoxElt);\r\n                break;\r\n            case _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.ContentObjectType.String:\r\n                const valueContainer = document.createElement('span');\r\n                valueContainer.classList.add(\"bp--value-container\");\r\n                valueContainer.innerText = tailBox.value;\r\n                tailBoxElt.appendChild(valueContainer);\r\n                break;\r\n            case _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.ContentObjectType.Rich:\r\n                for (const elt of tailBox.children) {\r\n                    tailBoxElt.appendChild(elt);\r\n                }\r\n                break;\r\n            case _types_ContentObject__WEBPACK_IMPORTED_MODULE_3__.ContentObjectType.Pointer:\r\n                const target = this.objectToEltBindings.get(tailBox.target);\r\n                if (target) {\r\n                    this.arrowBindings.push({ from: tailBoxElt, to: target, side: \"unknown\" });\r\n                }\r\n                else {\r\n                    const to = this.renderFromBoxObject(tailBox.target, row);\r\n                    this.arrowBindings.push({ from: tailBoxElt, to, side: to.classList.contains(\"bp--box\") ? \"Left\" : \"unknown\" });\r\n                }\r\n                break;\r\n        }\r\n        // Delaying this was necessary to make sure the recursive calls run in the correct order.\r\n        if (headBoxTargetUnknown) {\r\n            const to = this.renderFromBoxObject(headBox.target, this.pushRow([...row.children].slice(0, position)));\r\n            this.arrowBindings.push({ from: headBoxElt, to, side: to.classList.contains(\"bp--box\") ? \"Top\" : \"unknown\" });\r\n        }\r\n        return headBoxElt ?? tailBoxElt;\r\n    }\r\n}\r\ncustomElements.define('box-and-pointer', BoxAndPointerElement);\r\n//# sourceMappingURL=box-and-pointer.js.map\n\n//# sourceURL=webpack:///./dist/box-and-pointer.js?");

/***/ }),

/***/ "./dist/types/BoxObject.js":
/*!*********************************!*\
  !*** ./dist/types/BoxObject.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UIObjectType\": () => (/* binding */ UIObjectType),\n/* harmony export */   \"makeSingle\": () => (/* binding */ makeSingle),\n/* harmony export */   \"isSingle\": () => (/* binding */ isSingle),\n/* harmony export */   \"makePair\": () => (/* binding */ makePair),\n/* harmony export */   \"isPair\": () => (/* binding */ isPair)\n/* harmony export */ });\nvar UIObjectType;\r\n(function (UIObjectType) {\r\n    UIObjectType[UIObjectType[\"Single\"] = 0] = \"Single\";\r\n    UIObjectType[UIObjectType[\"Pair\"] = 1] = \"Pair\";\r\n})(UIObjectType || (UIObjectType = {}));\r\nfunction makeSingle(x) {\r\n    return {\r\n        ...x,\r\n        kind: UIObjectType.Single\r\n    };\r\n}\r\nfunction isSingle(x) {\r\n    return x.kind === UIObjectType.Single;\r\n}\r\nfunction makePair(x) {\r\n    return {\r\n        ...x,\r\n        kind: UIObjectType.Pair\r\n    };\r\n}\r\nfunction isPair(x) {\r\n    return x.kind === UIObjectType.Pair;\r\n}\r\n//# sourceMappingURL=BoxObject.js.map\n\n//# sourceURL=webpack:///./dist/types/BoxObject.js?");

/***/ }),

/***/ "./dist/types/ContentObject.js":
/*!*************************************!*\
  !*** ./dist/types/ContentObject.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ContentObjectType\": () => (/* binding */ ContentObjectType),\n/* harmony export */   \"makePointer\": () => (/* binding */ makePointer),\n/* harmony export */   \"makeNullPointer\": () => (/* binding */ makeNullPointer),\n/* harmony export */   \"transformContentObject\": () => (/* binding */ transformContentObject),\n/* harmony export */   \"isPointer\": () => (/* binding */ isPointer),\n/* harmony export */   \"makeString\": () => (/* binding */ makeString),\n/* harmony export */   \"isString\": () => (/* binding */ isString),\n/* harmony export */   \"makeRich\": () => (/* binding */ makeRich),\n/* harmony export */   \"isRich\": () => (/* binding */ isRich),\n/* harmony export */   \"emptySingleton\": () => (/* binding */ emptySingleton)\n/* harmony export */ });\nvar ContentObjectType;\r\n(function (ContentObjectType) {\r\n    ContentObjectType[ContentObjectType[\"Pointer\"] = 0] = \"Pointer\";\r\n    ContentObjectType[ContentObjectType[\"String\"] = 1] = \"String\";\r\n    ContentObjectType[ContentObjectType[\"Rich\"] = 2] = \"Rich\";\r\n    ContentObjectType[ContentObjectType[\"Empty\"] = 3] = \"Empty\";\r\n})(ContentObjectType || (ContentObjectType = {}));\r\nfunction makePointer(x) {\r\n    return {\r\n        ...x,\r\n        kind: ContentObjectType.Pointer\r\n    };\r\n}\r\nfunction makeNullPointer() {\r\n    return {\r\n        kind: ContentObjectType.Pointer\r\n    };\r\n}\r\nfunction transformContentObject(original, update) {\r\n    Object.assign(original, update);\r\n}\r\nfunction isPointer(x) {\r\n    return x.kind === ContentObjectType.Pointer;\r\n}\r\nfunction makeString(x) {\r\n    return {\r\n        ...x,\r\n        kind: ContentObjectType.String\r\n    };\r\n}\r\nfunction isString(x) {\r\n    return x.kind === ContentObjectType.String;\r\n}\r\nfunction makeRich(x) {\r\n    return {\r\n        ...x,\r\n        kind: ContentObjectType.Rich\r\n    };\r\n}\r\nfunction isRich(x) {\r\n    return x.kind === ContentObjectType.Rich;\r\n}\r\nconst emptySingleton = { kind: ContentObjectType.Empty };\r\n//# sourceMappingURL=ContentObject.js.map\n\n//# sourceURL=webpack:///./dist/types/ContentObject.js?");

/***/ }),

/***/ "./dist/types/ElementInfo.js":
/*!***********************************!*\
  !*** ./dist/types/ElementInfo.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Tags\": () => (/* binding */ Tags),\n/* harmony export */   \"Attributes\": () => (/* binding */ Attributes),\n/* harmony export */   \"internalElementTagNames\": () => (/* binding */ internalElementTagNames)\n/* harmony export */ });\nvar Tags;\r\n(function (Tags) {\r\n    // Box Elements\r\n    Tags[\"Box\"] = \"BOX\";\r\n    Tags[\"Pair\"] = \"PAIR\";\r\n    Tags[\"List\"] = \"LIST\";\r\n    Tags[\"Lisp\"] = \"LISP\";\r\n    // Value Elements\r\n    Tags[\"Value\"] = \"VALUE\";\r\n    Tags[\"Pointer\"] = \"POINTER\";\r\n    Tags[\"Empty\"] = \"EMPTY\";\r\n})(Tags || (Tags = {}));\r\nvar Attributes;\r\n(function (Attributes) {\r\n    Attributes[\"Name\"] = \"name\";\r\n    Attributes[\"Ref\"] = \"ref\";\r\n    Attributes[\"ExplicitTail\"] = \"explicit-tail\";\r\n    Attributes[\"ForceRoot\"] = \"force-root\";\r\n})(Attributes || (Attributes = {}));\r\nconst internalElementTagNames = new Set(Object.values(Tags));\r\n//# sourceMappingURL=ElementInfo.js.map\n\n//# sourceURL=webpack:///./dist/types/ElementInfo.js?");

/***/ }),

/***/ "./node_modules/html-parsed-element/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/html-parsed-element/esm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*! (c) Andrea Giammarchi - ISC */\nconst HTMLParsedElement = (() => {\n  const DCL = 'DOMContentLoaded';\n  const init = new WeakMap;\n  const queue = [];\n  const isParsed = el => {\n    do {\n      if (el.nextSibling)\n        return true;\n    } while (el = el.parentNode);\n    return false;\n  };\n  const upgrade = () => {\n    queue.splice(0).forEach(info => {\n      if (init.get(info[0]) !== true) {\n        init.set(info[0], true);\n        info[0][info[1]]();\n      }\n    });\n  };\n  document.addEventListener(DCL, upgrade);\n  class HTMLParsedElement extends HTMLElement {\n    static withParsedCallback(Class, name = 'parsed') {\n      const {prototype} = Class;\n      const {connectedCallback} = prototype;\n      const method = name + 'Callback';\n      const cleanUp = (el, observer, ownerDocument, onDCL) => {\n        observer.disconnect();\n        ownerDocument.removeEventListener(DCL, onDCL);\n        parsedCallback(el);\n      };\n      const parsedCallback = el => {\n        if (!queue.length)\n          requestAnimationFrame(upgrade);\n        queue.push([el, method]);\n      };\n      Object.defineProperties(\n        prototype,\n        {\n          connectedCallback: {\n            configurable: true,\n            writable: true,\n            value() {\n              if (connectedCallback)\n                connectedCallback.apply(this, arguments);\n              if (method in this && !init.has(this)) {\n                const self = this;\n                const {ownerDocument} = self;\n                init.set(self, false);\n                if (ownerDocument.readyState === 'complete' || isParsed(self))\n                  parsedCallback(self);\n                else {\n                  const onDCL = () => cleanUp(self, observer, ownerDocument, onDCL);\n                  ownerDocument.addEventListener(DCL, onDCL);\n                  const observer = new MutationObserver(() => {\n                    /* istanbul ignore else */\n                    if (isParsed(self))\n                      cleanUp(self, observer, ownerDocument, onDCL);\n                  });\n                  observer.observe(self.parentNode, {childList: true, subtree: true});\n                }\n              }\n            }\n          },\n          [name]: {\n            configurable: true,\n            get() {\n              return init.get(this) === true;\n            }\n          }\n        }\n      );\n      return Class;\n    }\n  }\n  return HTMLParsedElement.withParsedCallback(HTMLParsedElement);\n})();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HTMLParsedElement);\n\n\n//# sourceURL=webpack:///./node_modules/html-parsed-element/esm/index.js?");

/***/ }),

/***/ "./node_modules/sparse/dist/helper.js":
/*!********************************************!*\
  !*** ./node_modules/sparse/dist/helper.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.getCountOfChar = void 0;\r\nconst getCountOfChar = (target, char) => {\r\n    let ct = 0;\r\n    for (let i = 0; i < target.length; i++)\r\n        if (target[i] === char)\r\n            ct++;\r\n    return ct;\r\n};\r\nexports.getCountOfChar = getCountOfChar;\r\n\n\n//# sourceURL=webpack:///./node_modules/sparse/dist/helper.js?");

/***/ }),

/***/ "./node_modules/sparse/dist/index.js":
/*!*******************************************!*\
  !*** ./node_modules/sparse/dist/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SExpression = exports.parse = void 0;\r\nconst parser_1 = __webpack_require__(/*! ./parser */ \"./node_modules/sparse/dist/parser.js\");\r\nObject.defineProperty(exports, \"parse\", ({ enumerable: true, get: function () { return parser_1.parse; } }));\r\nconst sexpr_1 = __importDefault(__webpack_require__(/*! ./sexpr */ \"./node_modules/sparse/dist/sexpr.js\"));\r\nexports.SExpression = sexpr_1.default;\r\n\n\n//# sourceURL=webpack:///./node_modules/sparse/dist/index.js?");

/***/ }),

/***/ "./node_modules/sparse/dist/parser.js":
/*!********************************************!*\
  !*** ./node_modules/sparse/dist/parser.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.parse = void 0;\r\nconst sexpr_1 = __importDefault(__webpack_require__(/*! ./sexpr */ \"./node_modules/sparse/dist/sexpr.js\"));\r\nconst tokenizer_1 = __webpack_require__(/*! ./tokenizer */ \"./node_modules/sparse/dist/tokenizer.js\");\r\nconst parse = (input) => {\r\n    let bracketStack = [];\r\n    let sexprStack = [];\r\n    let originalSexpr = new sexpr_1.default();\r\n    let currentSexpr = originalSexpr;\r\n    let dottedSexprs = [];\r\n    let errorList = [];\r\n    for (let token of tokenizer_1.tokenize(input)) {\r\n        try {\r\n            if (token.type === tokenizer_1.TokenType.Bracket) {\r\n                let bracket = token.value;\r\n                if (bracket.dir === tokenizer_1.BracketDirection.Start) {\r\n                    bracketStack.push(bracket.shape);\r\n                    if (dottedSexprs[dottedSexprs.length - 1] === currentSexpr) {\r\n                        if (currentSexpr.tail !== undefined) {\r\n                            errorList.push({ pos: token.positionInfo, message: \"A dot may only be followed by one value.\" });\r\n                            dottedSexprs.pop();\r\n                        }\r\n                        else {\r\n                            currentSexpr.tail = new sexpr_1.default();\r\n                            sexprStack.push(currentSexpr);\r\n                            currentSexpr = currentSexpr.tail;\r\n                            continue;\r\n                        }\r\n                    }\r\n                    if (currentSexpr.head !== undefined) {\r\n                        currentSexpr.tail = new sexpr_1.default();\r\n                        currentSexpr = currentSexpr.tail;\r\n                    }\r\n                    currentSexpr.head = new sexpr_1.default();\r\n                    sexprStack.push(currentSexpr);\r\n                    currentSexpr = currentSexpr.head;\r\n                }\r\n                else {\r\n                    if (dottedSexprs.length > 0 && dottedSexprs[dottedSexprs.length - 1] === currentSexpr) {\r\n                        if (currentSexpr.tail === undefined) {\r\n                            errorList.push({ pos: token.positionInfo, message: \"A dot must have a value following it.\" });\r\n                        }\r\n                        dottedSexprs.pop();\r\n                    }\r\n                    if (bracketStack[bracketStack.length - 1] !== bracket.shape) {\r\n                        errorList.push({ pos: token.positionInfo, message: \"Mismatched closing bracket.\" });\r\n                        while (bracketStack.length > 0 && bracketStack.pop() !== bracket.shape) {\r\n                            if (dottedSexprs.length > 0 && dottedSexprs[dottedSexprs.length - 1] === currentSexpr) {\r\n                                dottedSexprs.pop();\r\n                            }\r\n                            currentSexpr.tail = currentSexpr.tail || null;\r\n                            currentSexpr = sexprStack.pop();\r\n                        }\r\n                    }\r\n                    if (currentSexpr.head === undefined) {\r\n                        const innerSexpr = currentSexpr;\r\n                        currentSexpr = sexprStack.pop();\r\n                        if (currentSexpr === undefined) {\r\n                            errorList.push({ pos: token.positionInfo, message: \"Missing closing bracket.\" });\r\n                        }\r\n                        else {\r\n                            if (currentSexpr.head === innerSexpr) {\r\n                                currentSexpr.head = null;\r\n                            }\r\n                            else if (currentSexpr.tail === innerSexpr) {\r\n                                currentSexpr.tail = null;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        currentSexpr.tail = currentSexpr.tail || null;\r\n                        currentSexpr = sexprStack.pop();\r\n                        if (currentSexpr === undefined) {\r\n                            errorList.push({ pos: token.positionInfo, message: \"Missing closing bracket.\" });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if (token.type === tokenizer_1.TokenType.Name) {\r\n                if (dottedSexprs.length > 0 && dottedSexprs[dottedSexprs.length - 1] === currentSexpr) {\r\n                    if (currentSexpr.tail !== undefined) {\r\n                        errorList.push({ pos: token.positionInfo, message: \"A dot may only be followed by one value.\" });\r\n                        dottedSexprs.pop();\r\n                    }\r\n                    else {\r\n                        currentSexpr.tail = token.value;\r\n                        continue;\r\n                    }\r\n                }\r\n                if (currentSexpr.head !== undefined) {\r\n                    currentSexpr.tail = new sexpr_1.default();\r\n                    currentSexpr = currentSexpr.tail;\r\n                }\r\n                currentSexpr.head = token.value;\r\n            }\r\n            else if (token.type === tokenizer_1.TokenType.Dot) {\r\n                if (currentSexpr.head === undefined) {\r\n                    errorList.push({ pos: token.positionInfo, message: \"A dot must have a value preceeding it.\" });\r\n                }\r\n                else {\r\n                    dottedSexprs.push(currentSexpr);\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n        }\r\n    }\r\n    currentSexpr.tail = currentSexpr.tail || null;\r\n    errorList.length > 0 && console.error(errorList.map(x => `${x.pos.row}, ${x.pos.col}: ${x.message}`).join(\"\\n\"));\r\n    return originalSexpr;\r\n};\r\nexports.parse = parse;\r\n\n\n//# sourceURL=webpack:///./node_modules/sparse/dist/parser.js?");

/***/ }),

/***/ "./node_modules/sparse/dist/sexpr.js":
/*!*******************************************!*\
  !*** ./node_modules/sparse/dist/sexpr.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nclass SExpression {\r\n    constructor(head, tail) {\r\n        this.head = head;\r\n        this.tail = tail;\r\n    }\r\n    toString() {\r\n        let result = \"\";\r\n        if (this.head instanceof SExpression) {\r\n            result += `(${this.head.toString()})`;\r\n        }\r\n        else if (this.head === null) {\r\n            result += '()';\r\n        }\r\n        else {\r\n            result += this.head;\r\n        }\r\n        if (this.tail === null) {\r\n        }\r\n        else if (this.tail instanceof SExpression) {\r\n            result += ` ${this.tail.toString()}`;\r\n        }\r\n        else {\r\n            result += ` . ${this.tail}`;\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexports.default = SExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/sparse/dist/sexpr.js?");

/***/ }),

/***/ "./node_modules/sparse/dist/tokenizer.js":
/*!***********************************************!*\
  !*** ./node_modules/sparse/dist/tokenizer.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.BracketShape = exports.BracketDirection = exports.TokenType = exports.tokenize = void 0;\r\nconst helper_1 = __webpack_require__(/*! ./helper */ \"./node_modules/sparse/dist/helper.js\");\r\nconst whitespace = \" \\n\\r\\t\";\r\nconst brackets = \"()[]{}\";\r\nconst tokenize = function* (input) {\r\n    let i = 0;\r\n    let line = 1;\r\n    let chr = 0;\r\n    let token = \"\";\r\n    while (i < input.length) {\r\n        if (input[i] === \";\") {\r\n            while (input[++i] !== \"\\n\")\r\n                ;\r\n            i++;\r\n        }\r\n        else if (whitespace.includes(input[i])) {\r\n            if (token !== \"\") {\r\n                yield new Token(TokenType.Name, token, { row: line, col: chr });\r\n                token = \"\";\r\n                chr += token.length;\r\n            }\r\n            else if (input[i] === \"\\n\") {\r\n                line++;\r\n                chr = 1;\r\n            }\r\n            chr++;\r\n            i++;\r\n        }\r\n        else if (brackets.includes(input[i])) {\r\n            if (token !== \"\") {\r\n                yield new Token(TokenType.Name, token, { row: line, col: chr });\r\n                token = \"\";\r\n                chr += token.length;\r\n            }\r\n            yield new Token(TokenType.Bracket, BracketIdentifier[input[i++]], { row: line, col: chr++ });\r\n        }\r\n        else if (input[i] === \"\\\"\") {\r\n            if (token !== \"\") {\r\n                yield new Token(TokenType.Name, token, { row: line, col: chr });\r\n                token = \"\";\r\n                chr += token.length;\r\n            }\r\n            let j = i + 1;\r\n            while (j < input.length) {\r\n                j = input.indexOf(\"\\\"\", j);\r\n                if (j === -1) {\r\n                    break;\r\n                }\r\n                let escapeCount = 0;\r\n                for (let k = 1; input[j - k] === \"\\\\\"; k++) {\r\n                    escapeCount++;\r\n                }\r\n                if (escapeCount % 2 == 0) {\r\n                    let str = input.substring(i, j + 1);\r\n                    yield new Token(TokenType.Name, str, { row: line, col: chr });\r\n                    let newlines = helper_1.getCountOfChar(str, \"\\n\");\r\n                    line += newlines;\r\n                    if (newlines > 0) {\r\n                        chr = str.length - str.lastIndexOf(\"\\n\");\r\n                    }\r\n                    else {\r\n                        chr += str.length;\r\n                    }\r\n                    i = j + 1;\r\n                    break;\r\n                }\r\n                else {\r\n                    j++;\r\n                }\r\n            }\r\n            if (j === -1) {\r\n                return;\r\n            }\r\n        }\r\n        else if (token === \"\" && input[i] === '.') {\r\n            yield new Token(TokenType.Dot, '.', { row: line, col: chr });\r\n            chr++;\r\n            i++;\r\n        }\r\n        else {\r\n            token += input[i++];\r\n        }\r\n    }\r\n    if (token !== \"\") {\r\n        yield new Token(TokenType.Name, token, { row: line, col: chr });\r\n        token = \"\";\r\n        chr += token.length;\r\n    }\r\n};\r\nexports.tokenize = tokenize;\r\nclass Token {\r\n    constructor(type, value, positionInfo) {\r\n        this.type = type;\r\n        this.value = value;\r\n        this.positionInfo = positionInfo;\r\n    }\r\n}\r\nvar TokenType;\r\n(function (TokenType) {\r\n    TokenType[TokenType[\"Bracket\"] = 0] = \"Bracket\";\r\n    TokenType[TokenType[\"Name\"] = 1] = \"Name\";\r\n    TokenType[TokenType[\"Dot\"] = 2] = \"Dot\";\r\n})(TokenType = exports.TokenType || (exports.TokenType = {}));\r\nvar BracketDirection;\r\n(function (BracketDirection) {\r\n    BracketDirection[BracketDirection[\"Start\"] = 0] = \"Start\";\r\n    BracketDirection[BracketDirection[\"End\"] = 1] = \"End\";\r\n})(BracketDirection = exports.BracketDirection || (exports.BracketDirection = {}));\r\nvar BracketShape;\r\n(function (BracketShape) {\r\n    BracketShape[BracketShape[\"Paren\"] = 0] = \"Paren\";\r\n    BracketShape[BracketShape[\"Curly\"] = 1] = \"Curly\";\r\n    BracketShape[BracketShape[\"Square\"] = 2] = \"Square\";\r\n})(BracketShape = exports.BracketShape || (exports.BracketShape = {}));\r\nconst BracketIdentifier = {\r\n    \"(\": { shape: BracketShape.Paren, dir: BracketDirection.Start },\r\n    \")\": { shape: BracketShape.Paren, dir: BracketDirection.End },\r\n    \"{\": { shape: BracketShape.Curly, dir: BracketDirection.Start },\r\n    \"}\": { shape: BracketShape.Curly, dir: BracketDirection.End },\r\n    \"[\": { shape: BracketShape.Square, dir: BracketDirection.Start },\r\n    \"]\": { shape: BracketShape.Square, dir: BracketDirection.End }\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/sparse/dist/tokenizer.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./dist/box-and-pointer.js");
/******/ 	
/******/ })()
;